<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BigInt Calculator (HTML example)</title>
  <style>
    :root{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    body{max-width:900px;margin:32px auto;padding:18px;border-radius:12px;background:#f7f7fb}
    .card{background:white;padding:18px;border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,.06)}
    input[type=text]{width:100%;padding:12px;font-size:16px;border-radius:8px;border:1px solid #ddd}
    .row{display:flex;gap:8px;margin-top:10px}
    button{padding:10px 12px;border-radius:8px;border:1px solid #bbb;background:#fff;cursor:pointer}
    pre{white-space:pre-wrap;word-break:break-word;background:#111;color:#e6fffa;padding:12px;border-radius:8px;overflow:auto;max-height:350px}
    .note{font-size:13px;color:#444;margin-top:8px}
    .tiny{font-size:12px;color:#666}
  </style>
</head>
<body>
  <div class="card">
    <h2>BigInt Calculator â€” HTML example</h2>
    <p class="tiny">Supports integers of arbitrary size (BigInt). Operators: <code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>^</code> and parentheses. Division returns integer quotient and remainder. Example: <code>2^100000</code>.</p>

    <label for="expr">Expression</label>
    <input id="expr" type="text" placeholder="e.g. (2^100000 - 1) / 3" value="2^100000">

    <div class="row">
      <button id="evalBtn">Evaluate</button>
      <button id="clearBtn">Clear</button>
      <button id="copyBtn">Copy result</button>
      <button id="downloadBtn">Download result</button>
    </div>

    <p class="note">Notes: exponentiation <code>^</code> is right-associative (so <code>2^3^2</code> = <code>2^(3^2)</code>). Inputs are treated as integers. Decimal/fraction support is not provided here.</p>

    <h3>Result</h3>
    <pre id="result">(no result yet)</pre>
  </div>

<script>
// Tokenize expression into numbers, operators, parentheses
function tokenize(s){
  const tokens = [];
  const re = /\s*([0-9]+|\^|\*|\/|\+|\-|\(|\))/g;
  let m;
  while((m = re.exec(s)) !== null){
    tokens.push(m[1]);
  }
  return tokens;
}

// Shunting-yard to RPN
const OPS = {
  '+':{prec: 2, assoc: 'L'},
  '-':{prec: 2, assoc: 'L'},
  '*':{prec: 3, assoc: 'L'},
  '/':{prec: 3, assoc: 'L'},
  '^':{prec: 4, assoc: 'R'}
};

function toRPN(tokens){
  const out = [];
  const opStack = [];
  for(const t of tokens){
    if(/^[0-9]+$/.test(t)){
      out.push(t);
    } else if(t in OPS){
      const o1 = t;
      while(opStack.length){
        const o2 = opStack[opStack.length-1];
        if(!(o2 in OPS)) break;
        if((OPS[o1].assoc === 'L' && OPS[o1].prec <= OPS[o2].prec) || (OPS[o1].assoc === 'R' && OPS[o1].prec < OPS[o2].prec)){
          out.push(opStack.pop());
        } else break;
      }
      opStack.push(o1);
    } else if(t === '('){
      opStack.push(t);
    } else if(t === ')'){
      while(opStack.length && opStack[opStack.length-1] !== '(') out.push(opStack.pop());
      if(opStack.length === 0) throw new Error('Mismatched parentheses');
      opStack.pop(); // pop '('
    } else {
      throw new Error('Invalid token: ' + t);
    }
  }
  while(opStack.length){
    const v = opStack.pop();
    if(v === '(' || v === ')') throw new Error('Mismatched parentheses');
    out.push(v);
  }
  return out;
}

// Fast exponentiation where base and exponent are BigInt; exponent must be >= 0
function bigPow(base, exp){
  if(exp < 0n) throw new Error('Negative exponent not supported for integers');
  let result = 1n;
  let b = base;
  let e = exp;
  while(e > 0n){
    if(e & 1n) result = result * b;
    b = b * b;
    e = e >> 1n;
  }
  return result;
}

function evalRPN(rpn){
  const st = [];
  for(const t of rpn){
    if(/^[0-9]+$/.test(t)){
      st.push(BigInt(t));
    } else if(t === '+'){
      const b = st.pop(); const a = st.pop(); st.push(a + b);
    } else if(t === '-'){
      const b = st.pop(); const a = st.pop(); st.push(a - b);
    } else if(t === '*'){
      const b = st.pop(); const a = st.pop(); st.push(a * b);
    } else if(t === '/'){
      const b = st.pop(); const a = st.pop();
      if(b === 0n) throw new Error('Division by zero');
      const q = a / b; // integer division (trunc toward zero in JS BigInt)
      const r = a % b;
      // We'll store as an object to report both quotient and remainder
      st.push({__QR: true, q: q, r: r});
    } else if(t === '^'){
      const expToken = st.pop(); const baseToken = st.pop();
      // If either token is a quotient object from division, that's unsupported in further ops
      function ensureBigInt(x){
        if(x && x.__QR) throw new Error('Cannot use quotient/remainder object in further arithmetic. Parenthesize or use integers.');
        return BigInt(x);
      }
      const exponent = ensureBigInt(expToken);
      const base = ensureBigInt(baseToken);
      if(exponent < 0n) throw new Error('Negative exponent not supported for integer BigInt power');
      st.push(bigPow(base, exponent));
    } else {
      throw new Error('Unknown RPN token: ' + t);
    }
  }
  if(st.length !== 1) throw new Error('Invalid expression');
  return st[0];
}

function evaluateExpression(s){
  const tokens = tokenize(s);
  if(tokens.length === 0) throw new Error('Empty expression');
  const rpn = toRPN(tokens);
  return evalRPN(rpn);
}

// UI wiring
const exprEl = document.getElementById('expr');
const resEl = document.getElementById('result');
const evalBtn = document.getElementById('evalBtn');
const clearBtn = document.getElementById('clearBtn');
const copyBtn = document.getElementById('copyBtn');
const downloadBtn = document.getElementById('downloadBtn');

evalBtn.addEventListener('click', ()=>{
  resEl.textContent = 'Computing...';
  try{
    const out = evaluateExpression(exprEl.value.trim());
    if(out && out.__QR){
      resEl.textContent = 'Quotient: ' + out.q.toString() + '\nRemainder: ' + out.r.toString();
    } else {
      const sOut = out.toString();
      // If very large, show first/last 200 chars and provide full via download
      if(sOut.length > 20000){
        resEl.textContent = '(very large result: ' + sOut.length + ' digits)\n' + sOut.slice(0,200) + '\n...\n' + sOut.slice(-200);
      } else {
        resEl.textContent = sOut;
      }
    }
  } catch(e){
    resEl.textContent = 'Error: ' + e.message;
  }
});

clearBtn.addEventListener('click', ()=>{ exprEl.value = ''; resEl.textContent = '(no result yet)'; });

copyBtn.addEventListener('click', async ()=>{
  try{
    await navigator.clipboard.writeText(resEl.textContent);
    alert('Result copied to clipboard');
  } catch(e){ alert('Copy failed: ' + e.message); }
});

downloadBtn.addEventListener('click', ()=>{
  const blob = new Blob([resEl.textContent], {type: 'text/plain;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'calculator-result.txt';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
});

// Allow pressing Enter in the input to evaluate
exprEl.addEventListener('keydown', (ev)=>{ if(ev.key === 'Enter') { ev.preventDefault(); evalBtn.click(); } });

</script>
</body>
</html>
